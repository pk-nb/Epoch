{div, form, button, p, h1, hr, span, img, input, label, a} = React.DOM

unless Array::filter
  Array::filter = (callback) ->
    element for element in this when callback(element)


TimelinePanel = React.createClass
  displayName: 'TimelinePanel'

  onPostSuccess: (data) ->
      console.log data
      console.log @props.timelines
      timelines = @props.timelines
      timelines.push(data)
      #
      @props.setAppState(timelines: timelines)

  onPostError: (messages) ->
    # Render error by setting state
    console.log 'Ajax failure'
    console.log(messages)
    @props.setAppState(timeline_errors: messages)


  handleSubmit: (e) ->
    console.log 'Submit form'
    e.preventDefault()
    $.ajax {
      type: 'POST',
      url: Routes.timelines_path(),
      data: $(@refs.newTimelineForm.getDOMNode()).serialize(),
      dataType: 'json'

      success: (data, status, xhr) =>
        console.log 'Ajax success'
        @onPostSuccess(data)
        @refs.newTimelineForm.getDOMNode().reset()

      error: (xhr, status, error) =>
        # Retrieve/parse error messages from response text
        messages = [];
        try messages = JSON.parse(xhr.responseText).errors
        catch e then messages = [xhr.responseText]
        @onPostError(messages)
    }

  handleRepoSubmit: (e) ->
    e.preventDefault()
    $.ajax {
      type: 'POST',
      url: Routes.repository_index_path(),
      data: $(@refs.newRepoForm.getDOMNode()).serialize(),
      dataType: 'json'

      success: (data, status, xhr) =>
        console.log 'Ajax success'
        # todo IJH 11/30/14: do we only want to add the top level timeline in the success callback?
        @onPostSuccess(data)
        @refs.newRepoForm.getDOMNode().reset()

      error: (xhr, status, error) =>
        # Retrieve/parse error messages from response text
        messages = [];
        try messages = JSON.parse(xhr.responseText).errors
        catch e then messages = [xhr.responseText]
        # todo IJH 11/23/2014: errors will need to be changed to display by the appropriate form
        @onPostError(messages)
    }

  handleTweetSubmit: (e) ->
    e.preventDefault()
    form_data = $(@refs.newTweetForm.getDOMNode()).serialize()
    # if the user hasn't chosen an option from the selector, use the text field value
    $.ajax {
      type: 'POST',
      url: Routes.tweets_path(),
      data: form_data,
      dataType: 'json'

      success: (data, status, xhr) =>
        console.log 'Ajax success'
        @onPostSuccess(data)
        @refs.newTweetForm.getDOMNode().reset()

      error: (xhr, status, error) =>
        # Retrieve/parse error messages from response text
        messages = [];
        try messages = JSON.parse(xhr.responseText).errors
        catch e then messages = [xhr.responseText]
        # todo IJH 11/30/2014: errors will need to be changed to display by the appropriate form
        @onPostError(messages)
    }

  unselectedTimelines: ->
    tIds = @props.timelines.map (timeline) ->
      timeline.id
    @props.userTimelines.filter (userTimeline) =>
       userTimeline.id not in tIds


  addSelectedTimeline: (data) ->
    newTimelines = $.extend(true, [], @props.timelines)
    newTimelines.push(data)
    @props.setAppState(timelines: newTimelines)


  handleSelectTimeline: (id) ->
    =>
      # TODO Start spinner state here and end spinner state in success method

      # Request timeline and append to selected timelines
      $.ajax {
        type: 'GET',
        url: Routes.timeline_path(id),
        dataType: 'json'

        success: (data, status, xhr) =>
          @addSelectedTimeline(data)

        error: (xhr, status, error) =>
          # TODO Error handling in view with state
          console.log error
      }

  handleRemoveTimeline: (id) ->
    =>
      newTimelines = $.extend(true, [], @props.timelines).filter (timeline) ->
        timeline.id != id
      @props.setAppState(timelines: newTimelines)

  userTimelinesSection: ->
    if @props.user
      div null,
        h1 null,
          "#{@props.user.name}'s Timelines"
        @userTimelineList()

  userTimelineList: ->
    @unselectedTimelines().map (timeline) =>
      div {key: timeline.title + timeline.id, className: 'timeline-item'},
        div className: 'title',
          div className: 'circle',
            ''
          span null,
            timeline.title
        div className: 'icons',
          img { onClick: @handleSelectTimeline(timeline.id), className: 'plus-icon', src: '<%= asset_path 'plus-icon.svg' %>'}

  timelineList: ->
    if @props.timelines.length > 0
      @props.timelines.map (timeline) =>
        div {key: timeline.title, className: 'timeline-item'},
          div className: 'title',
            div className: 'circle',
              ''
            span null,
              timeline.title
          div className: 'icons',
            img { onClick: @handleRemoveTimeline(timeline.id), className: 'x-icon', src: '<%= asset_path 'x-icon.svg' %>'}
    else
      p null,
        'No Selected Timelines'

  handleAddRepoName: ->
    (e) =>
      e.preventDefault()
      # todo we may want more direct dom manipulation here to avoid resetting the list?
      repos = @props.repos
      repo_input = $(@refs.addRepo.getDOMNode())
      repos.push(repo_input.val())
      repo_input.val('')
      @props.setAppState(repos: repos)

  renderTimelineErrors: ->
    div className: 'form-errors',
      @props.timeline_errors.map (error) =>
        p null,
          error

  render: ->
    Forms = window.EpochForms
    div className: 'panel timeline-panel',
      h1 null,
        'Selected Timelines'
      @timelineList(),
      @userTimelinesSection(),
      h1 null,
        'New Timeline'
      @renderTimelineErrors()
      form ref: 'newTimelineForm', onSubmit: @handleSubmit,
        div dangerouslySetInnerHTML: { __html: Forms.newTimeline },
          null
        button null,
          'Submit'
      # Github import form
      h1 null,
          'Import from Github'
      form ref: 'newRepoForm', onSubmit: @handleRepoSubmit,
        div dangerouslySetInnerHTML: { __html: Forms.newRepository },
            null
        div null,
          label htmlFor: 'name',
            'Timeline Name'
          input {type: 'text', className: 'narrow-input', name: 'name'}
        @props.repos.map (repo) =>
          div key: repo,
            input { type: 'checkbox', name: 'repos[]', value: repo},
              repo
        div null,
          label htmlFor: 'additional_repo',
                'Other Repo'
          input {ref: 'addRepo', type: 'text', className: 'narrow-input', name: 'additional_repo'}
          button onClick: @handleAddRepoName(),
           'Add To List'
        button null,
          'Submit'
      # Twitter import form
      h1 null,
        'Import from Twitter'
      form ref: 'newTweetForm', onSubmit: @handleTweetSubmit,
        div dangerouslySetInnerHTML: { __html: Forms.newTweet },
         null
        button null,
         'Submit'


@.EpochUI ?= {}
@.EpochUI.TimelinePanel = TimelinePanel
